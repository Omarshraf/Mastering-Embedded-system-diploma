/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

// Terminal1 <-----> USART1 : MCU1 : (SPI1 Master) ----> (SPI2 Slave) : MCU2 : USART -----> Terminal2

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define MCU_Act_As_Master
//#define MCU_Act_As_Slave


#include "stm32f103x6.h"
#include "Stm32_F103C6_gpio_drivers.h"
#include "Stm32_F103C6_EXTI_drivers.h"
#include "Stm32_F103C6_USART_drivers.h"
#include "Stm32_F103C6_SPI_drivers.h"
#include "Stm32_F103C6_RCC_drivers.h"


GPIO_PinConfig_t PinCfg;


void clock_init() {
	//Enable clock GPIOA
	RCC_GPIOA_CLK_EN();
	//Enable clock GPIOB
	RCC_GPIOB_CLK_EN();
	//Enable clock GPIOB
	RCC_AFIO_CLK_EN();
}

uint16_t ch;
void UART_IRQ_Callback (void)
{
#ifdef MCU_Act_As_Master
	MCAL_UART_ReceiveData(USART1, &ch, disable);
	MCAL_UART_SendData(USART1, &ch, enable);
	//send to SPI
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 0);
	MCAL_SPI_TX_RX(SPI1, &ch, Pollingenable);
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 1);
#endif
}



int main(void)
{
	UART_Config uartCfg;

	clock_init();

	//==========================UART INIT==============================
	/*
	 * PA9  TX
	 * PA10 RX
	 * PA11 CTS
	 * PA12 RTS
	 */
	uartCfg.BaudRate = UART_BaudRate_115200;
	uartCfg.HwFlowCtl = UART_HwFlowCtl_NONE;
	uartCfg.IRQ_Enable = UART_IRQ_Enable_NONE;
	uartCfg.P_IRQ_CallBack = NULL;
	uartCfg.Parity = UART_Parity_NONE;
	uartCfg.Payload_length = UART_Payload_length_8B;
	uartCfg.StopBits = UART_StopBits_1;
	uartCfg.Mode = UART_Mode_TX_RX;
	MCAL_UART_Init(USART1, &uartCfg);
	MCAL_UART_GPIO_Set_Pins(USART1);


	//==========================SPI INIT==============================
	/*
	 * PA4  SPI1_NSS
	 * PA5  SPI1_SCK
	 * PA6  SPI1_MISO
	 * PA7  SPI1_MOSI
	 */
	SPI_Config SPI1CFG;
	//Common configuration
	SPI1CFG.CLKPhase = SPI_Clock_Phase_2EDGE_second_data_capture_edge;
	SPI1CFG.CLKPolarity = SPI_SPI_CLKPolarity_HIGH_when_idle;
	SPI1CFG.Data_Size = SPI_DataSize_8BIT;
	SPI1CFG.Frame_Format = SPI_Frame_Format_MSB;
	//Assume by defult pclk2 = 8MHz
	SPI1CFG.BAUDRATEPRESCALER = SPI_BAUDRATEPRESCALER_8;
	SPI1CFG.Communication_Mode =SPI_DIRECTION_2LINES;

#ifdef MCU_Act_As_Master
	SPI1CFG.Device_Mode = SPI_Device_Mode_MASTER;
	SPI1CFG.IRQ_Enable = SPI_IRQ_Enable_NONE;
	SPI1CFG.NSS = SPI_NSS_Soft_NSSInternalSoft_Set;
	SPI1CFG.P_IRQ_CallBack = NULL;
#endif
	MCAL_SPI_Init(SPI1, &SPI1CFG);
	MCAL_SPI_GPIO_Set_Pins(SPI1);


	//configuration SS on PA.4 by GPIO
	PinCfg.GPIO_PinNumber = GPIO_PIN_4;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPT_PP;
	PinCfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOA, &PinCfg);

	//Force the Slave Select (High) idel Mode
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 1);


    /* Loop forever */
	while(1)
	{

	}
}
